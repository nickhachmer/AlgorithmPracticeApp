number,difficulty,name,link,tags,algorithms,description
3,medium,Longest Substring Without Repeating Characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/,(sliding window),,Use hash map and two indices. You move one index inserting elemnts into the hashmap. When you find a repeat in the hashmap you record the current size of the substring and increment the second pointer until you pass the repeated char ----------------------
5,medium,Longest Palindromic Substring,https://leetcode.com/problems/longest-palindromic-substring/,(dp),Manacher's Algorithm,"Solution 1: create a function that checks the existence of a palindrome expanding from the middle index. Then you just iterate over the characters in the string checking the plaindrom centered on a string or on two strings. 

Solution 2: (dp) you build up a 2d array you start with single length palindrome strings then you check all substrings of length two and determine the longest palindrome between them. Then you do three and above by looking at the ends of the palindrome - if the ends are not the same then the largest possible is the maximum of the largest possible between the start and end. When they are equal you check to see if left++ and right-- substring is palindrome and if it is then you have a new largest.

Solution 3:"
7,"easy ",Reversed Integer,https://leetcode.com/problems/reverse-integer/,,,
9,"easy ",Palindrome Number,https://leetcode.com/problems/palindrome-number/,,,if negative return false. Reverse the int with modulus division and compare to original. Or convert to string and use string operations.
26,"easy ",Remove Duplicates from Sorted Array,https://leetcode.com/problems/remove-duplicates-from-sorted-array/,(two pointers),,two pointers. Linerarlly iterate over with one pointer as place to insert and the other as looking over the array. Whenever the right pointer and left pointer are not the same you insert the right to ++left. Note that this will insert an element onto itself sometimes when the numbers are not duplicate.
31,medium,Next Permutation,https://leetcode.com/problems/next-permutation/,,,"You identify the last number in the array that is not decreasing. (if you did not find one, as in all decreasing then reverse the array). Once found, find the smallest number that is greater than the current number that you found from the last step, use <= to compare if their are duplicates. Then you swap the current number and the number found. Then the sub sequence after the current numbers index will be in decreasing order which is the maximum, thus you revers its order by swaping and then you are done."
33,medium,Search in Rotated Sorted Array,https://leetcode.com/problems/search-in-rotated-sorted-array/,(binary search),,"find pivot via binary search. Then do din search on both halves of the array.

Can also do binary search but within condition of mid > left you do another check to see if target is in the range of mid and left. If it is then normal bin search if it is not then is on the other side of mid so left = mid+1. simliar for mid < left."
35,easy,Search Insert Position,https://leetcode.com/problems/search-insert-position/,,,"Binary search. At the end, if not found, either return left index+1 if target greater or left index otherwise."
39,medium,Combination Sum,https://leetcode.com/problems/combination-sum/,,,"Sort and remove duplicates. Then recurse. General idea is to start from the end and try to get the sum to target or to 0. if the current number you are looking at makes sum >= 0 you recurse. Base case is sum == 0, then just add to result array and return."
46,medium,Permutation,https://leetcode.com/problems/permutations/,,Heap's Algorithm,"Idea is to generate each permuation from the previous permuation by choosing a pair of elements to interchange, without distburing the other n-2 elements

recurse. When size is 1 add permutation. Otherwise loop through from j = 0 to size recursing on new size = size-1 and new i = previous i. After recursion in loop if size is odd swap first with last otherise swap i with last."
48,medium,Rotate Image,https://leetcode.com/problems/rotate-image/,,,Can do the formula. Or can relfect in the diagonal and then reverse each row. (orignal -> transposed -> transposed + reversed)
53,easy,Maximum Subarray,https://leetcode.com/problems/maximum-subarray/,(dp),Kadane's Algorithm,use dynamic programming to either take the current element or the previous maximum subarry with current element
58,easy,Length of Last Word,https://leetcode.com/problems/length-of-last-word/,,,Linearly iterate backwards until you come across a new space character. Then start incrementing counter until you come across a space character again.
62,medium,Unique Paths,https://leetcode.com/problems/unique-paths/,(dp),,use dynamic programming. For a given cell it is the sum of possible paths from cell above and cell to the left. Doing recursive gave better time
64,medium,Minimum Path Sum,https://leetcode.com/problems/minimum-path-sum/,(dp),Dijkstra's Algorithm,dynamic programming where you do the first row and first column. Then do the rest by summing the min of left or top to current value. Return bottom right of array.
66,easy,Plus One,https://leetcode.com/problems/plus-one/,,,Linearly iterate backwards adding 1 and if overflow set to 0 and go to next otherwise break. If I == 0 break and check after if array at 0 is 10 then push back 0 and clear all to 0 and set the first to 1.
70,easy,Climbing Stairs,https://leetcode.com/problems/climbing-stairs/,(dp),,"dynamic programming, i = i-1 + i-2"
78,medium,Subsets,https://leetcode.com/problems/subsets/,,,You start by adding the empty set to the output. Then for each number you add it do the subsets already in the output.
92,medium,Reverse Linked List ii,https://leetcode.com/problems/reverse-linked-list-ii/,,,Can do recursively or iteratively. Go along with two pointers one prev and one curr until curr is found left position. Then point the curr to the prev and keep going until you are at right position. Then if the start which is the place the prev when you found the left is not null then start next is prev and otherwise head is prev. then end which was curr at left position end->next is curr.
94,"easy ",Binary Tree Inorder Traversal,https://leetcode.com/problems/binary-tree-inorder-traversal/,,,loop through left first then right
96,medium,Unique Binary Search Trees,https://leetcode.com/problems/unique-binary-search-trees/,(dp),,"Its like a function composition in math. Using dynamic programming you multiply the value just before the current index and the first. Then sum with the second last with second and so on. "
98,medium,Validate Binary Search Tree,https://leetcode.com/problems/validate-binary-search-tree/,,,recursively look at each node once and carry with you the min and max values that value can be as you go down. When going to left the max is the current  val -1 and the right is min is current val +1
100,easy,Same Tree,https://leetcode.com/problems/same-tree/,,,Iterate and check all conditions
101,easy,Symmetic Tree,https://leetcode.com/problems/symmetric-tree/,,,Use recursion. Check if the current two nodes are the same - if they are then check that their children are the same. So you check left->left with right->right and left->right with right->left
110,easy,Balanced Binary Tree,https://leetcode.com/problems/balanced-binary-tree/,,,recursively go down until nullptr at which point return 0 - you return the height. Go back up and grab the hieght of the left and right and compare the diff and then return the largets height + 1
111,easy,Minimum Dpeth of Binary Tree,https://leetcode.com/problems/minimum-depth-of-binary-tree/,,,"Recurse in the main function and check conditions. If left null go right, if right null go left otherwise take the min of both and when recurse add 1 to result."
112,easy,Path Sum,https://leetcode.com/problems/path-sum/,,,"recurse down the tree summing up the values , if you reach the sum then check if leaf and return true if so. Otherwise return true if left or right is true."
118,"easy ",Pascal's Triangle,https://leetcode.com/problems/pascals-triangle/,,,intial condition of 0. loop through adding previous rows with exceptions of ends which you know to be 1. thus you can just add 1 and for middle index have a loop make them
137,medium,Signle Number ii,https://leetcode.com/problems/single-number-ii/submissions/,,,"can sort then check, can use hash map, can use bit operations where you add the bits at each position and mod by 3 so that if you see a number 3 times their bits will cancel as the count for those bits will be 3 and mod 3 is then 0. Also can do the one and two bit way where you add the bit to one if not in two and add it to two and clear from one. if in two then clear from both."
141,easy,Linked List Cycle,https://leetcode.com/problems/linked-list-cycle/,(two pointers),,"use two pointers - one fast , one slow. Fast goes every 2 and slow 1 step at a time. If there is a cycle it will find it. Make sure to stagger the fast and slow pointers at beginning so fast = head->next;"
144,easy,Binary Tree Preorder Traversal,https://leetcode.com/problems/binary-tree-preorder-traversal/,,,As you do
160,"easy ",Intersection of Two Linked Lists,https://leetcode.com/problems/intersection-of-two-linked-lists/,,,Find the lengths of each linked list. Calculate difference and then for the longest one iterate over the first x elements where x = difference. Then just iterate over pboth linked lists until they intersect or they do not.
169,easy,Majority Element,https://leetcode.com/problems/majority-element/,,,"By nature of the problem, since there will always be a majority > floor of n/2 we increment counter if we come across the same number otherwise we decement. When the counter is 0 we get the current number at i."
190,easy,Reverse Bits,https://leetcode.com/problems/reverse-bits/,,,iterate until current number is 0. you simply add the first bit of the current number bit shifted to the next spot (bit shifted by a decrasing counter). Then you remove the first bit from the current number and decrease the counter.
202,easy,Happy Number,https://leetcode.com/problems/happy-number/,,,"Recurse by doing the operation on the current number and store in a hash set then if you see 1 return true if not check if in hash set if so false, otherwise continue."
206,"easy ",Reverse Linked List,,,,
217,"easy ",Contains Duplicate,https://leetcode.com/problems/contains-duplicate/,,,hash set and insert and check or can sort and check next index hash set while O(n) can perform slower than sorting on small inputs due to overhead.
226,"easy ",Invert Binary Tree,https://leetcode.com/problems/invert-binary-tree/,,,recursion. Recurse on left and right. Then we take the results and put them to the opposite child (left to right) (right to left)
234,"easy ",Palindrome Linked List,https://leetcode.com/problems/palindrome-linked-list/,,,have two pointers where one goes twice as fast across a linked list. once at the end take the one at half way and reverse it then compare
237,easy,Delete Node in a Linked List,https://leetcode.com/problems/delete-node-in-a-linked-list/,,,you move the value of next into the current and delete the next
238,"easy ",Move Zeros,,,,"linear loop over check if curr is non zero, if non zero then place at place of last recorded zero, else do nothing. When you place at last recorded you increment the last zero index by 1. At the end you go from last recored to end of array filling with zeros."
260,medium,Single Number iii,https://leetcode.com/problems/single-number-iii/,,,You do as you did for the first one. And you will be left with a number that has a 1 where the two numbers are different and a 0 where they are the same. You then find the first bit there they differ - which is the first bit that is 1 in the created value by xor all the values (xy &= -xy). then with this number containing the bit use it to filter the two by &. so you iterate over the array again and if the bit matches xor with one value in the result otherwise the other value - this way the two values you are looking for a are kept seperate and thus do not combine and the rest cancel eachother out.
279,medium,Perfect Squares,https://leetcode.com/problems/perfect-squares/,(dp),,"use dp by keeping track of the number of squares it takes to sum to a given number. Then iterate from 4 to n as you know 0-3. As you iterate you set dp at I to be I since this is the maximum. Then you go from 1 to square root of i and see if dp at n-i*i is better than current dp at i. Basically you subract a prime from the current nubmer i and see if the dp at the difference + 1 is better. "
338,easy,Counting Bits,https://leetcode.com/problems/counting-bits/,"(dp) ",Kernignhan's Algorithm,every time you multiply by two - you bit shif the number. so we divide by two to get the numbers of 1s in th bits after the first bit and then use (i & 1) to check if it is odd / even. Could use Kernignhan's Algorithm - take a number - iterate until it is 0. while iterating subtract 1 and bit wise & with itself. and increment counter.
367,easy,Valid Perfect Square,https://leetcode.com/problems/valid-perfect-square/,,,"iterate while i = 1 and i <= num, check if square is equal - if so return true else if square is greater than then return false. Also could have i be long long and check if i is even and if num / i is i "
392,easy,Is Subsequence,https://leetcode.com/problems/is-subsequence/,,,linearly iterate over the main string then use index to keep track of which part of substring has been matched
404,easy,Sum of Left Leaves,https://leetcode.com/problems/sum-of-left-leaves/,,,"recurse down to tree with parameter is left. If the current node is leaf and is left, then return val of node otherwise return 0. if not leaf node then return the sum of the left and right where recursing on left you pass isLeft as true"
429,medium,N-ary Tree Level Order Traversal,https://leetcode.com/problems/n-ary-tree-level-order-traversal/,,,recurse down the tree while keeping track of the level you are at. Use the level to index the resulting vector and put the current node in the result at the level.
441,easy,Arranging Coins,https://leetcode.com/problems/arranging-coins/,,,iterate while n >=  row and subtract n by row and increment row and then return row-1. better is to use binary search where target is value using the formula - use the formula with current value and see if it matches n other wise continue and just use the right side at the end if none found. Also could use Formula (sqrt(8*n+1) - 1) /2 - this comes from k(k+1) <= 2n where k is number of complete stairs and n is number of coins.
448,easy,Find All Numbers Disappeared in an Array,https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/,,,"Trick is to find a way to keep track of what numbers you came across. Can use hash map, boolean array. Best idea is make the value at the index of the number you are looking at negative and only deal with the absolute values."
494,medium,Target Sum,https://leetcode.com/problems/target-sum/,"(dp) ",,"Recurse. Base case is when index is end of array then check if the usm is target and increment count if so. Other wise you recurse by adding current index to sum or subtracting and then icreasing index. To make more efficient use memoization with 2d array. where you keep track of the index and the sum "
520,easy,Detect Capital,https://leetcode.com/problems/detect-capital/,,,"consider the 3 cases. Can use flags and count the number of times you see a lower and upper,then just do a check at the end."
543,easy,Diameter of Binary Tree,,,,"linear time, DFS, need to keep track of longest path of left and right child as well as longest diameter of both children can return longest path and use global varable or pointer maybe for longest diameter"
561,easy,Array Partition i,https://leetcode.com/problems/array-partition-i/,,,Sort then sum every other number starting from index 0
589,easy,N-ary Tree Preorder Traversal,https://leetcode.com/problems/n-ary-tree-preorder-traversal/,,,pre orer - use a stack for iterative and then reverse the children as you put them in the stack
590,easy,N-ary Tree Postorder Traversal,https://leetcode.com/problems/n-ary-tree-postorder-traversal/,,,normal post order traversal. Can do recursivly or iteratively (using a stack for iterative). Start with root on stack iterate until stack is empty and put val of pop off stack into queue then add children to stack
617,easy,Merge Two Binary Trees,https://leetcode.com/problems/merge-two-binary-trees/,,,"recursion, think of being at a particular node and recursing on it. Return the other node trees node if current is null. If both non null we sum the values and merge the children recursively then return the node."
633,medium,Sum of Square Numbers,https://leetcode.com/problems/sum-of-square-numbers/,,,"brute force, brute force with c -a^2. use sqrt funciton on c-a^2 and see if result is an int. Fermats Theorem. Binary search which is a varition on better brute force with c-a^2."
647,medium,Palindromic Substring,https://leetcode.com/problems/palindromic-substrings/,,,"Iterate over the entire string and starting from current index count planidromes you can form, then check with current index and index + 1"
896,easy,Monotonic Array,https://leetcode.com/problems/monotonic-array/,,,Can do one pas or two passes either is same time complexity
1047,easy,Remove All Adjacent Duplicates In String,https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/,,,Linearly iterate over string and move stack pointer if duplicates are found. Other wise keep adding characters to stack and then put all chars to string and return it
1358,medium,Number of Substrings Containing All Three Characters,https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/,,,