number,difficulty,name,link,geeksforgeeks,description,tags,algorithms
3,medium,Longest Substring Without Repeating Characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/,,Use hash map and two indices. You move one index inserting elemnts into the hashmap. When you find a repeat in the hashmap you record the current size of the substring and increment the second pointer until you pass the repeated char,(sliding window),
5,medium,Longest Palindromic Substring,https://leetcode.com/problems/longest-palindromic-substring/,,"Solution 1: create a function that checks the existence of a palindrome expanding from the middle index. Then you just iterate over the characters in the string checking the plaindrom centered on a string or on two strings. 

Solution 2: (dp) you build up a 2d array you start with single length palindrome strings then you check all substrings of length two and determine the longest palindrome between them. Then you do three and above by looking at the ends of the palindrome - if the ends are not the same then the largest possible is the maximum of the largest possible between the start and end. When they are equal you check to see if left++ and right-- substring is palindrome and if it is then you have a new largest.

Solution 3:",(dp),Manacher's Algorithm
7,easy ,Reversed Integer,https://leetcode.com/problems/reverse-integer/,,,,
9,easy ,Palindrome Number,https://leetcode.com/problems/palindrome-number/,,if negative return false. Reverse the int with modulus division and compare to original. Or convert to string and use string operations.,,
26,easy ,Remove Duplicates from Sorted Array,https://leetcode.com/problems/remove-duplicates-from-sorted-array/,,two pointers. Linerarlly iterate over with one pointer as place to insert and the other as looking over the array. Whenever the right pointer and left pointer are not the same you insert the right to ++left. Note that this will insert an element onto itself sometimes when the numbers are not duplicate.,(two pointers),
31,medium,Next Permutation,https://leetcode.com/problems/next-permutation/,,"You identify the last number in the array that is not decreasing. (if you did not find one, as in all decreasing then reverse the array). Once found, find the smallest number that is greater than the current number that you found from the last step, use <= to compare if their are duplicates. Then you swap the current number and the number found. Then the sub sequence after the current numbers index will be in decreasing order which is the maximum, thus you revers its order by swaping and then you are done.",,
33,medium,Search in Rotated Sorted Array,https://leetcode.com/problems/search-in-rotated-sorted-array/,https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/,"find pivot via binary search. Then do din search on both halves of the array.

Can also do binary search but within condition of mid > left you do another check to see if target is in the range of mid and left. If it is then normal bin search if it is not then is on the other side of mid so left = mid+1. simliar for mid < left.",(binary search),
35,easy,Search Insert Position,https://leetcode.com/problems/search-insert-position/,,"Binary search. At the end, if not found, either return left index+1 if target greater or left index otherwise.",,
36,medium,Valid Sudoku,https://leetcode.com/problems/valid-sudoku/,,"Can use hash set, array or length 9, bitmasking - using bits in an int",,
39,medium,Combination Sum,https://leetcode.com/problems/combination-sum/,,"Sort and remove duplicates. Then recurse. General idea is to start from the end and try to get the sum to target or to 0. if the current number you are looking at makes sum >= 0 you recurse. Base case is sum == 0, then just add to result array and return.",,
46,medium,Permutation,https://leetcode.com/problems/permutations/,geeksforgeeks.org/heaps-algorithm-for-generating-permutations/,"Idea is to generate each permuation from the previous permuation by choosing a pair of elements to interchange, without distburing the other n-2 elements

recurse. When size is 1 add permutation. Otherwise loop through from j = 0 to size recursing on new size = size-1 and new i = previous i. After recursion in loop if size is odd swap first with last otherise swap i with last.",,Heap's Algorithm
48,medium,Rotate Image,https://leetcode.com/problems/rotate-image/,,Can do the formula. Or can relfect in the diagonal and then reverse each row. (orignal -> transposed -> transposed + reversed),,
53,easy,Maximum Subarray,https://leetcode.com/problems/maximum-subarray/,,use dynamic programming to either take the current element or the previous maximum subarry with current element,(dp),Kadane's Algorithm
58,easy,Length of Last Word,https://leetcode.com/problems/length-of-last-word/,,Linearly iterate backwards until you come across a new space character. Then start incrementing counter until you come across a space character again.,,
62,medium,Unique Paths,https://leetcode.com/problems/unique-paths/,,use dynamic programming. For a given cell it is the sum of possible paths from cell above and cell to the left. Doing recursive gave better time,(dp),
64,medium,Minimum Path Sum,https://leetcode.com/problems/minimum-path-sum/,https://www.geeksforgeeks.org/min-cost-path-dp-6/,dynamic programming where you do the first row and first column. Then do the rest by summing the min of left or top to current value. Return bottom right of array.,(dp),Dijkstra's Algorithm
66,easy,Plus One,https://leetcode.com/problems/plus-one/,,Linearly iterate backwards adding 1 and if overflow set to 0 and go to next otherwise break. If I == 0 break and check after if array at 0 is 10 then push back 0 and clear all to 0 and set the first to 1.,,
70,easy,Climbing Stairs,https://leetcode.com/problems/climbing-stairs/,,"dynamic programming, i = i-1 + i-2",(dp),
73,medium,Set Matrix Zeroes,https://leetcode.com/problems/set-matrix-zeroes/,,"best way is to iterate through, store the columna dn row of the zeroes you find. Then go through the rows you find and make the entire row 0s. Then do the same for the col - only do the ones you found - this is a good optimization. Another important optimization is storeing the size of the rows and col in the matrix so it won't have to calculate it each time.",,
78,medium,Subsets,https://leetcode.com/problems/subsets/,,You start by adding the empty set to the output. Then for each number you add it do the subsets already in the output.,,
83,easy,Remove Duplicates from Sorted List,https://leetcode.com/problems/remove-duplicates-from-sorted-list/,,I did recursively by traversing down then as we propagate back up we remove duplicates. Could also do iteratively on the first pass down,,
91,medium,Decode Ways,https://leetcode.com/problems/decode-ways/,,"Use dynamic programming where you use the previous sub strings combinations to for the next ones based on the conditions of current char being 0, being non 0 and can combine with previous char or non zero and cannot combine",(dp),
92,medium,Reverse Linked List ii,https://leetcode.com/problems/reverse-linked-list-ii/,,Can do recursively or iteratively. Go along with two pointers one prev and one curr until curr is found left position. Then point the curr to the prev and keep going until you are at right position. Then if the start which is the place the prev when you found the left is not null then start next is prev and otherwise head is prev. then end which was curr at left position end->next is curr.,,
94,easy ,Binary Tree Inorder Traversal,https://leetcode.com/problems/binary-tree-inorder-traversal/,,loop through left first then right,,
96,medium,Unique Binary Search Trees,https://leetcode.com/problems/unique-binary-search-trees/,https://www.geeksforgeeks.org/construct-all-possible-bsts-for-keys-1-to-n/,Its like a function composition in math. Using dynamic programming you multiply the value just before the current index and the first. Then sum with the second last with second and so on. ,(dp),
98,medium,Validate Binary Search Tree,https://leetcode.com/problems/validate-binary-search-tree/,https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/,recursively look at each node once and carry with you the min and max values that value can be as you go down. When going to left the max is the current  val -1 and the right is min is current val +1,,
100,easy,Same Tree,https://leetcode.com/problems/same-tree/,,Iterate and check all conditions,,
101,easy,Symmetic Tree,https://leetcode.com/problems/symmetric-tree/,,Use recursion. Check if the current two nodes are the same - if they are then check that their children are the same. So you check left->left with right->right and left->right with right->left,,
110,easy,Balanced Binary Tree,https://leetcode.com/problems/balanced-binary-tree/,,recursively go down until nullptr at which point return 0 - you return the height. Go back up and grab the hieght of the left and right and compare the diff and then return the largets height + 1,,
111,easy,Minimum Dpeth of Binary Tree,https://leetcode.com/problems/minimum-depth-of-binary-tree/,,"Recurse in the main function and check conditions. If left null go right, if right null go left otherwise take the min of both and when recurse add 1 to result.",,
112,easy,Path Sum,https://leetcode.com/problems/path-sum/,,"recurse down the tree summing up the values , if you reach the sum then check if leaf and return true if so. Otherwise return true if left or right is true.",,
118,easy ,Pascal's Triangle,https://leetcode.com/problems/pascals-triangle/,,intial condition of 0. loop through adding previous rows with exceptions of ends which you know to be 1. thus you can just add 1 and for middle index have a loop make them,,
137,medium,Signle Number ii,https://leetcode.com/problems/single-number-ii/submissions/,,"can sort then check, can use hash map, can use bit operations where you add the bits at each position and mod by 3 so that if you see a number 3 times their bits will cancel as the count for those bits will be 3 and mod 3 is then 0. Also can do the one and two bit way where you add the bit to one if not in two and add it to two and clear from one. if in two then clear from both.",,
141,easy,Linked List Cycle,https://leetcode.com/problems/linked-list-cycle/,,"use two pointers - one fast , one slow. Fast goes every 2 and slow 1 step at a time. If there is a cycle it will find it. Make sure to stagger the fast and slow pointers at beginning so fast = head->next;",(two pointers),
144,easy,Binary Tree Preorder Traversal,https://leetcode.com/problems/binary-tree-preorder-traversal/,,As you do,,
145,easy,Binary Tree Postorder Traversal,https://leetcode.com/problems/binary-tree-postorder-traversal/,,As you do,,
153,medium,Find Minimum in Rotated Sorted Array,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/,,bin ary search if mid is greater than start / left then go to the right otherwise go to the left. Each iteration check to see if left is less than right. Or can check the middle value by seeing if it is less than the previous or greater than the next,(binary search),
160,easy ,Intersection of Two Linked Lists,https://leetcode.com/problems/intersection-of-two-linked-lists/,,Find the lengths of each linked list. Calculate difference and then for the longest one iterate over the first x elements where x = difference. Then just iterate over pboth linked lists until they intersect or they do not.,,
168,easy,Excel Sheet Column Title,https://leetcode.com/problems/excel-sheet-column-title/,,itï¿½s a conversion to hex type question. ,,
169,easy,Majority Element,https://leetcode.com/problems/majority-element/,,"By nature of the problem, since there will always be a majority > floor of n/2 we increment counter if we come across the same number otherwise we decement. When the counter is 0 we get the current number at i.",,
190,easy,Reverse Bits,https://leetcode.com/problems/reverse-bits/,,iterate until current number is 0. you simply add the first bit of the current number bit shifted to the next spot (bit shifted by a decrasing counter). Then you remove the first bit from the current number and decrease the counter.,,
202,easy,Happy Number,https://leetcode.com/problems/happy-number/,,"Recurse by doing the operation on the current number and store in a hash set then if you see 1 return true if not check if in hash set if so false, otherwise continue.",,
205,easy,Isomorphic Strings,https://leetcode.com/problems/isomorphic-strings/,,You can use 2 dictionaries to keep track of the duplicates. Can also use the fact that since they are isomorphic to transform the string into something else - specficially using the first occurrence of each char in the string and comparing that,,
206,easy ,Reverse Linked List,https://leetcode.com/problems/reverse-linked-list/,,can do iterative. Recursive is difficult - gootta use the next next of the current node.,,
217,easy ,Contains Duplicate,https://leetcode.com/problems/contains-duplicate/,,hash set and insert and check or can sort and check next index hash set while O(n) can perform slower than sorting on small inputs due to overhead.,,
226,easy ,Invert Binary Tree,https://leetcode.com/problems/invert-binary-tree/,,recursion. Recurse on left and right. Then we take the results and put them to the opposite child (left to right) (right to left),,
234,easy ,Palindrome Linked List,https://leetcode.com/problems/palindrome-linked-list/,,have two pointers where one goes twice as fast across a linked list. once at the end take the one at half way and reverse it then compare,,
237,easy,Delete Node in a Linked List,https://leetcode.com/problems/delete-node-in-a-linked-list/,,you move the value of next into the current and delete the next,,
238,easy ,Move Zeros,,,"linear loop over check if curr is non zero, if non zero then place at place of last recorded zero, else do nothing. When you place at last recorded you increment the last zero index by 1. At the end you go from last recored to end of array filling with zeros.",,
260,medium,Single Number iii,https://leetcode.com/problems/single-number-iii/,,You do as you did for the first one. And you will be left with a number that has a 1 where the two numbers are different and a 0 where they are the same. You then find the first bit there they differ - which is the first bit that is 1 in the created value by xor all the values (xy &= -xy). then with this number containing the bit use it to filter the two by &. so you iterate over the array again and if the bit matches xor with one value in the result otherwise the other value - this way the two values you are looking for a are kept seperate and thus do not combine and the rest cancel eachother out.,,
279,medium,Perfect Squares,https://leetcode.com/problems/perfect-squares/,https://www.geeksforgeeks.org/minimum-number-of-squares-whose-sum-equals-to-given-number-n/,use dp by keeping track of the number of squares it takes to sum to a given number. Then iterate from 4 to n as you know 0-3. As you iterate you set dp at I to be I since this is the maximum. Then you go from 1 to square root of i and see if dp at n-i*i is better than current dp at i. Basically you subract a prime from the current nubmer i and see if the dp at the difference + 1 is better. ,(dp),
303,easy,Range Sum Query - Immutable,https://leetcode.com/problems/range-sum-query-immutable/,,you can do it as you would. The smart way is use dynamic programming. So in the constructor oyu create the array by summing up all the values up until that index. Then when you calculate the sum range it is just the difference between right+1 and left.,(dp),
338,easy,Counting Bits,https://leetcode.com/problems/counting-bits/,,every time you multiply by two - you bit shif the number. so we divide by two to get the numbers of 1s in th bits after the first bit and then use (i & 1) to check if it is odd / even. Could use Kernignhan's Algorithm - take a number - iterate until it is 0. while iterating subtract 1 and bit wise & with itself. and increment counter.,(dp) ,Kernignhan's Algorithm
344,easy,Reverse String,https://leetcode.com/problems/reverse-string/,,just swap first with last and so on. Best to use two indices and then bring to the center.,,
349,easy,Intersection of Two Arrays,https://leetcode.com/problems/intersection-of-two-arrays/,,"use hash set and add all elements from one list into it, hash set will only have unique values in it. Then just iterate over the next and check it. ",,
367,easy,Valid Perfect Square,https://leetcode.com/problems/valid-perfect-square/,,"iterate while i = 1 and i <= num, check if square is equal - if so return true else if square is greater than then return false. Also could have i be long long and check if i is even and if num / i is i ",,
392,easy,Is Subsequence,https://leetcode.com/problems/is-subsequence/,,linearly iterate over the main string then use index to keep track of which part of substring has been matched,,
404,easy,Sum of Left Leaves,https://leetcode.com/problems/sum-of-left-leaves/,,"recurse down to tree with parameter is left. If the current node is leaf and is left, then return val of node otherwise return 0. if not leaf node then return the sum of the left and right where recursing on left you pass isLeft as true",,
415,easy,Add Strings,https://leetcode.com/problems/add-strings/,,have a convert to num funtion. Then just add the two digits and keep track of the overflow / carry. ,,
429,medium,N-ary Tree Level Order Traversal,https://leetcode.com/problems/n-ary-tree-level-order-traversal/,,recurse down the tree while keeping track of the level you are at. Use the level to index the resulting vector and put the current node in the result at the level.,,
441,easy,Arranging Coins,https://leetcode.com/problems/arranging-coins/,,iterate while n >=  row and subtract n by row and increment row and then return row-1. better is to use binary search where target is value using the formula - use the formula with current value and see if it matches n other wise continue and just use the right side at the end if none found. Also could use Formula (sqrt(8*n+1) - 1) /2 - this comes from k(k+1) <= 2n where k is number of complete stairs and n is number of coins.,,
448,easy,Find All Numbers Disappeared in an Array,https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/,,"Trick is to find a way to keep track of what numbers you came across. Can use hash map, boolean array. Best idea is make the value at the index of the number you are looking at negative and only deal with the absolute values.",,
494,medium,Target Sum,https://leetcode.com/problems/target-sum/,,Recurse. Base case is when index is end of array then check if the usm is target and increment count if so. Other wise you recurse by adding current index to sum or subtracting and then icreasing index. To make more efficient use memoization with 2d array. where you keep track of the index and the sum ,(dp) ,
509,easy,Fibonacci Number,https://leetcode.com/problems/fibonacci-number/,,recursion with memoization,(dp),
520,easy,Detect Capital,https://leetcode.com/problems/detect-capital/,,"consider the 3 cases. Can use flags and count the number of times you see a lower and upper,then just do a check at the end.",,
537,medium,Complex Number Multiplication,https://leetcode.com/problems/complex-number-multiplication/,,"As you would, can use string find, scanf, and then use to_string at the end",,
543,easy,Diameter of Binary Tree,,,"linear time, DFS, need to keep track of longest path of left and right child as well as longest diameter of both children can return longest path and use global varable or pointer maybe for longest diameter",,
561,easy,Array Partition i,https://leetcode.com/problems/array-partition-i/,,Sort then sum every other number starting from index 0,,
589,easy,N-ary Tree Preorder Traversal,https://leetcode.com/problems/n-ary-tree-preorder-traversal/,,pre orer - use a stack for iterative and then reverse the children as you put them in the stack,,
590,easy,N-ary Tree Postorder Traversal,https://leetcode.com/problems/n-ary-tree-postorder-traversal/,,normal post order traversal. Can do recursivly or iteratively (using a stack for iterative). Start with root on stack iterate until stack is empty and put val of pop off stack into queue then add children to stack,,
,,,,,,,
617,easy,Merge Two Binary Trees,https://leetcode.com/problems/merge-two-binary-trees/,,"recursion, think of being at a particular node and recursing on it. Return the other node trees node if current is null. If both non null we sum the values and merge the children recursively then return the node.",,
633,medium,Sum of Square Numbers,https://leetcode.com/problems/sum-of-square-numbers/,,"brute force, brute force with c -a^2. use sqrt funciton on c-a^2 and see if result is an int. Fermats Theorem. Binary search (reduce / increment the one you need to) which is a varition on better brute force with c-a^2.",,
647,medium,Palindromic Substring,https://leetcode.com/problems/palindromic-substrings/,https://www.geeksforgeeks.org/count-palindrome-sub-strings-string/,"Iterate over the entire string and starting from current index count planidromes you can form, then check with current index and index + 1",,
653,easy,Two Sum iv - Input is a BST,https://leetcode.com/problems/two-sum-iv-input-is-a-bst/,,went through each not and then for target - current I tried to find it in the BST.,,
821,easy,Shortest Distance to a Character,https://leetcode.com/problems/shortest-distance-to-a-character/,,"two passes, one from left to right mkaring the distance from the previous character. Then go from right to left taking the minimum of the current and the distance from the previous",,
896,easy,Monotonic Array,https://leetcode.com/problems/monotonic-array/,,Can do one pass or two passes either is same time complexity,,
926,easy,Flip String to Monotone Increasing,https://leetcode.com/problems/flip-string-to-monotone-increasing/,,Keep track of number of flips you need for each number while going through  the string. Start with numer of 1s in the string. Then go backwards and everytime you see 0 you increase the zero counter and everytime you see a 1 you decrease the 1 counter - after each iteration just sum the count of both and compare to the current lowest.,,
954,medium,Array of Doubled Pairs,https://leetcode.com/problems/array-of-doubled-pairs/,,"Find the freq of all numbers. Sort the array by abs value comparison. Go through the array and decrement the freq of the number and the double of the number. If the current number freq is = 0 skip it , other wise check to see if the double exists and has freq > 0 - else return false. then just return true at end",,
1047,easy,Remove All Adjacent Duplicates In String,https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/,,Linearly iterate over string and move stack pointer if duplicates are found. Other wise keep adding characters to stack and then put all chars to string and return it,,
1339,medium,Maximum Product of Splitted Binary Tree,https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/,,Do a dfs on the tree to find total sum of nodes. Then do another dfs doing the same things but this time keeping track of the maximum answer using the formular (total-sum)*sum,,
1358,medium,Number of Substrings Containing All Three Characters,https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/,,,,
1448,medium,Count Good Nodes in Binary Tree,https://leetcode.com/problems/count-good-nodes-in-binary-tree/,,recurse with maximum so far,,
1512,easy,Number of Good Pairs,https://leetcode.com/problems/number-of-good-pairs/,,Brute force by iterating with I and j starting from i checking if equal. Or Could use hash map and when you find a number you add its mapped value to the counter and increment its mapped value,,
1528,easy,Shuffle String,https://leetcode.com/problems/shuffle-string/,,do as you do. Or start from an index and then swap by using the next indices as pointers in a linked list. You basicaly traverse the tree.,,
1929,easy,Concatenation of Array,https://leetcode.com/problems/concatenation-of-array/,,as you would,,
1979,easy,Find Greatest Common Divisor of Array,https://leetcode.com/problems/find-greatest-common-divisor-of-array/,,"Could linearly find min and max and then from min go down to 1 until the number divides both.
Or could sort then gcd of the first element and last element.",,
